Drop n [] = []
Drop 0 lst = lst
Drop n h:tl = Drop (n - 1) tl
Drop n (String chars) = String (Drop n chars)

Take n [] = []
Take 0 lst = []
Take n h:tl = h : (Take (n - 1) tl)
Take n (String chars) = String (Take n chars)

Slice start len lst = Take len (Drop start lst)
Slice start len (String chars) = String (Slice start len chars)

Chars (String str) = str

Map f [] = []
Map f h:tl = (f h) : (Map f tl)
Map f (String chars) = String (Map f chars)

Str f (String chars) = String (f chars)

And True True = True
And True False = False
And False True = False
And False False = False

ToUpper (String chars) = String (Map (\c -> if (c >= 97) `And` (c <= 122) then c - 32 else c) chars)

IsList [] = True
IsList h:tl = True
IsList x = False

IsFun (Fun (String chars) args) = IsList args
IsFun x = False

IsVar (Var (String x)) = True
IsVar x = False

Len [] = 0
Len h:tl = (Len tl) + 1

Rev lst = Rev' lst []
Rev' [] acc = acc
Rev' h:tl acc = Rev' tl (h:acc)

Prepend as [] = as
Prepend [] bs = bs
Prepend a:as bs = a : (as `Prepend` bs)

Join lst = String (Join' (Rev lst) [])
Join' [] acc = acc
Join' (String h):tl acc = Join' tl (Prepend h acc)

JoinWith (String del) lst = String (JoinWith' del lst [])
JoinWith' del [] acc = acc
JoinWith' del [String h] acc = h `Prepend` acc
JoinWith' del (String h):tl acc = JoinWith' del tl ((h `Append` del) `Prepend` acc)

Append as bs = Prepend bs as

Zip as bs = Zip' as bs []
Zip' [] bs acc = Rev acc
Zip' as [] acc = Rev acc
Zip' a:as b:bs acc = Zip' as bs (a, b):acc

# Martelli and Montanari's term unification algorithm
Unify s t = Unify' [(s, t)] []
Unify' [] subst = Some subst
Unify' (Var a, Var a):ts subst = Unify' ts subst
Unify' (Var a, t):ts subst = Unify' ts (a, t):subst
Unify' (Fun f as, Fun f bs):tl subst =
    if (Len as == Len bs) then
        Unify' (Prepend (Zip as bs) tl) subst
    else None
Unify' (Fun f as, Fun g bs):tl subst = None
Unify' ts subst = None

Peano 0 = Fun "0" []
Peano n = Fun "S" [Peano n - 1] 

ParseTRS rules =
    let p = ParseTermDefined in
    Map (\(a, b) -> (p a, p b)) rules

Show t = String (Show' t)
Show' (Var (String x)) = x
Show' (Fun (String f) []) = f
Show' (Fun (String f) args) = 
    Prepend (Prepend f (Prepend (Chars "(") ((Chars (JoinWith ", " (Map Show (Rev args))))))) (Chars ")")

FindRule term [] = None
FindRule t (lhs, rhs):rules = FindRule' t (Unify lhs t) (lhs, rhs) rules
FindRule' t (Some subst) r rules = Some (r, subst)
FindRule' t a b rules = FindRule t rules

FindSubst x [] = Var x 
FindSubst x (x, z):tl = z
FindSubst x (y, z):tl = FindSubst x tl

Substitute (Var x) subst = FindSubst x subst
Substitute (Fun f args) subst = Fun f (Map (\t -> Substitute t subst) args)

Reduce (Fun f args) rules =
    let s = Fun f (Map (\t -> Normalize t rules) args) in
    Reduce' s (FindRule s rules)
Reduce (Var x) rules = (Var x, False)
Reduce' t None = (t, False)
Reduce' t (Some ((lhs, rhs), subst)) = (Substitute rhs subst, True)

Normalize term rules = Normalize' (term, True) rules
Normalize' (t, True) rules = Normalize' (Reduce t rules) rules
Normalize' (t, False) rules = t

CharCode (String [c]) = c

IsDigit (String [c]) = IsDigit c
IsDigit c = (c >= CharCode "0") `And` (c <= CharCode "9")

Success res out = Some (res, String out)

Fail cs = None

Satisfy test [] = Fail []
Satisfy test (String c):cs = Satisfy test c:cs
Satisfy test c:cs = if test c then Success (String [c]) cs else Fail c:cs

ParseDigit = Satisfy IsDigit
ParseChar (String [c]) = Satisfy (== c)

Then fst snd cs = Then' (fst cs) snd
Then' None snd = None
Then' (Some (r, String rem1)) snd = Then'' (snd rem1) r
Then'' None r = None
Then'' (Some (s, rem2)) r = Some ((r, s), rem2)

Alt fst snd cs = Alt' (fst cs) snd cs
Alt' None snd cs = snd cs
Alt' (Some res) snd cs = Some res

ParseLowerCase = Satisfy (\c -> (c >= CharCode "a") `And` (c <= CharCode "z"))
ParseUpperCase = Satisfy (\c -> (c >= CharCode "A") `And` (c <= CharCode "Z"))

ParseLetter = ParseLowerCase `Alt` ParseUpperCase
ParseLetters = MapParser Join (Many ParseLetter)

ParseAlphaNum = ParseLetter `Alt` ParseDigit
ParseAlphaNums = MapParser Join (Many ParseAlphaNum)

Many p cs = Many' (p cs) p ([], cs)
Many' None p (res, out) = Some (Rev res, String out)
Many' (Some (r, String rem)) p (res, out) = Many' (p rem) p (r:res, rem)

ParseSymb = MapParser (\(h, tl) -> Join [h, tl]) (((ParseUpperCase `Alt` ParseDigit) `Then` ParseAlphaNums))

ParseTerm = ParseFun `Alt` ParseVar

Fst (a, b) = a

ParseArgs = ParseArgs2 `Alt` (MapParser (\t -> [t]) ParseTerm)
ParseArgs2 =
    MapParser
    (\(args, last) -> Append [last] args)
    ((Many (MapParser Fst (ParseTerm `Then` (ParseChar ",")))) `Then` ParseTerm)

LazyThen fst snd cs = Then (fst ()) (snd ()) cs

ParseFun = ParseFun2 `Alt` ParseFun1
ParseFun1 = MapParser (\f -> Fun f []) ParseSymb
ParseFun2 =
    MapParser (\((f, args), p) -> Fun f args)
    (
        (\() ->
        MapParser Fst 
        (ParseSymb `Then` (ParseChar "("))) `LazyThen` (\() -> ParseArgs)) `Then` (ParseChar ")"
    )

ParseVar = MapParser (\(c, cs) -> Var (Join [c, cs])) ((ParseLowerCase `Then` ParseAlphaNums))

MapParser f p cs = MapParser' f (p cs)
MapParser' f None = None
MapParser' f (Some (r, rem)) = Some (f r, rem)

RemoveSpaces (String cs) = RemoveSpaces' cs []
RemoveSpaces' [] acc = String (Rev acc)
WhiteSpace = CharCode " "
RemoveSpaces' c:cs acc = RemoveSpaces' cs (if c == WhiteSpace then acc else c:acc) 

Unwrap (Some x) = x

Map f None = None
Map f (Some x) = Some (f x)

ParseTermDefined t = Unwrap (Map Fst (ParseTerm (Chars (RemoveSpaces t))))

PeanoTRS = ParseTRS [
        ("Add(a, 0)", "a"),
        ("Add(0, b)", "b"),
        ("Add(S(a), b)", "S(Add(a, b))"),
        ("Add(a, S(b))", "S(Add(a, b))"),
        ("Mult(a, 0)", "0"),
        ("Mult(0, b)", "0"),
        ("Mult(S(a), b)", "Add(Mult(a, b), b)"),
        ("Mult(a, S(b))", "Add(Mult(a, b), a)"),
        ("1", "S(0)"),
        ("2", "S(1)"),
        ("3", "S(2)"),
        ("4", "S(3)"),
        ("5", "S(4)"),
        ("6", "S(5)"),
        ("7", "S(6)"),
        ("8", "S(7)"),
        ("9", "S(8)"),
        ("10", "S(9)"),
        ("P(0)", "0"),
        ("P(S(n))", "n"),
        ("Range(n)", "Range2(n, Nil)"),
        ("Range2(0, acc)", "Cons(0, acc)"),
        ("Range2(n, acc)", "Range2(P(n), Cons(n, acc))"),
        ("Len(Nil)", "0"),
        ("Len(Cons(h, tl))", "S(Len(tl))")
    ]

Norm (String term) trs = Normalize (ParseTermDefined (String term)) trs

Main = Show (Norm "Len(Range(Mult(3, 7)))" PeanoTRS)
