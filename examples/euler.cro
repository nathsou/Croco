All pred [] = True
All pred h:tl = if (pred h) then (All pred tl) else False

Not True = False
Not False = True

Take 0 it = []
Take n EmptyIt = []
Take n (It h tl) = h : (Take (n - 1) (Iter tl))
Take n [] = []
Take n h:tl = h : (Take (n - 1) tl)

TakeAll EmptyIt = []
TakeAll (It h tl) = h : (TakeAll (Iter tl))

TakeWhile pred EmptyIt = []
TakeWhile pred (It h tl) = if pred h then h : (TakeWhile pred (Iter tl)) else []

Filter pred EmptyIt = EmptyIt
Filter pred (It h tl) = if pred h then It h (NextFilter pred tl) else Filter pred (Iter tl)
Iter (NextFilter pred tl) = Filter pred (Iter tl)

IsPrime 0 = False
IsPrime 1 = False
IsPrime 2 = True
IsPrime n = if n % 2 == 0 then False else IsPrime' n 3
IsPrime' n i = if i * i > n then True else if n % i == 0 then False else IsPrime' n (i + 2)

NatsFrom n = It n (NextNat n)
Iter (NextNat n) = NatsFrom (n + 1)

Nats = NatsFrom 0

Next (It h tl) = Iter tl

Nth EmptyIt n = None
Nth (It h tl) 0 = Some h
Nth x 0 = None
Nth (It h tl) n = Nth (Iter tl) (n - 1)

Map f EmptyIt = EmptyIt
Map f (It h tl) = It (f h) (NextMap f tl)
Map f [] = []
Map f h:tl = (f h) : (Map f tl)
Iter (NextMap f tl) = Map f (Iter tl)

Len = Fold (\x len -> len + 1) 0

Primes = Filter IsPrime Nats

Divisible a b = a % b == 0

Sum = Fold (\n acc -> n + acc) 0
Prod = Fold (\n acc -> n * acc) 1

Fold f base lst = Fold' f base lst
Fold' f acc [] = acc
Fold' f acc EmptyIt = acc
Fold' f acc h:tl = Fold' f (f h acc) tl
Fold' f acc (It h tl) = Fold' f (f h acc) (Iter tl)

Euler 1 = Sum (TakeWhile (\n -> n < 1000) (Filter (\n -> Or (Divisible n 3) (\() -> Divisible n 5)) Nats))

Fibs = Fibs' 1 2
Fibs' a b = It a (NextFib b (a + b))
Iter (NextFib a b) = Fibs' a b

Even n = Divisible n 2

Euler 2 = Sum (TakeWhile (\n -> n < 4000000) (Filter Even Fibs))

Factorize 1 = []
Factorize 2 = [2]
Factorize n = if Divisible n 2 then 2 : (Factorize (n / 2)) else Factorize' n 3
Factorize' n i = if i * i <= n then (if Divisible n i then i : (Factorize (n / i)) else Factorize' n (i + 2)) else [n]

Max h:tl = Max' tl h
Max' [] m = m
Max' h:tl m = Max' tl (if h > m then h else m)

Euler 3 = Max (Factorize 600851475143)

Div a b = let d = a / b in d - (d % 1)

Digits n = Digits' n []
Digits' 0 ds = 0:ds
Digits' 1 ds = 1:ds
Digits' 2 ds = 2:ds
Digits' 3 ds = 3:ds
Digits' 4 ds = 4:ds
Digits' 5 ds = 5:ds
Digits' 6 ds = 6:ds
Digits' 7 ds = 7:ds
Digits' 8 ds = 8:ds
Digits' 9 ds = 9:ds
Digits' n ds = Digits' (Div n 10) ((n % 10) : ds)

Rev lst = Rev' lst []
Rev' [] rev = rev
Rev' h:tl acc = Rev' tl (h:acc)

Palindrome n = PalindromeList (Digits n)
PalindromeList lst = lst == (Rev lst)

And True b = b ()
And False b = False

Or True b = True
Or False b = b ()

Euler 4 = LargestPalindrome 999 0
LargestPalindrome a max = if a >= 100 then let m = LargestPalindrome' a 999 max in LargestPalindrome (a - 1) (if m > max then m else max) else max
LargestPalindrome' a b m = if b < 100 then m else let p = a * b in LargestPalindrome' a (b - 1) (if (And (p > m) (\() -> Palindrome p)) then p else m)

Hd h:tl = h
Tl h:tl = tl

SmallestMultiple m = SmallestMultiple' m 1 2
SmallestMultiple' m n m = n
SmallestMultiple' m n i = SmallestMultiple' m (if Not (Divisible n i) then n * (Hd (Factorize i)) else n) (i + 1)

Euler 5 = SmallestMultiple 20

SumSquareDiff n = let [a, b] = [Sum (Take (n + 1) (Map (\n -> n * n) Nats)), Sum (Take (n + 1) Nats)] in (b * b) - a

Euler 6 = SumSquareDiff 100

Unwrap (Some x) = x
Unwrap [x] = x

Euler 7 = Unwrap (Nth Primes 10000)

Euler8Data = [7, 3, 1, 6, 7, 1, 7, 6, 5, 3, 1, 3, 3, 0, 6, 2, 4, 9, 1, 9, 2, 2, 5, 1, 1, 9, 6, 7, 4, 4, 2, 6, 5, 7, 4, 7, 4, 2, 3, 5, 5, 3, 4, 9, 1, 9, 4, 9, 3, 4, 9, 6, 9, 8, 3, 5, 2, 0, 3, 1, 2, 7, 7, 4, 5, 0, 6, 3, 2, 6, 2, 3, 9, 5, 7, 8, 3, 1, 8, 0, 1, 6, 9, 8, 4, 8, 0, 1, 8, 6, 9, 4, 7, 8, 8, 5, 1, 8, 4, 3, 8, 5, 8, 6, 1, 5, 6, 0, 7, 8, 9, 1, 1, 2, 9, 4, 9, 4, 9, 5, 4, 5, 9, 5, 0, 1, 7, 3, 7, 9, 5, 8, 3, 3, 1, 9, 5, 2, 8, 5, 3, 2, 0, 8, 8, 0, 5, 5, 1, 1, 1, 2, 5, 4, 0, 6, 9, 8, 7, 4, 7, 1, 5, 8, 5, 2, 3, 8, 6, 3, 0, 5, 0, 7, 1, 5, 6, 9, 3, 2, 9, 0, 9, 6, 3, 2, 9, 5, 2, 2, 7, 4, 4, 3, 0, 4, 3, 5, 5, 7, 6, 6, 8, 9, 6, 6, 4, 8, 9, 5, 0, 4, 4, 5, 2, 4, 4, 5, 2, 3, 1, 6, 1, 7, 3, 1, 8, 5, 6, 4, 0, 3, 0, 9, 8, 7, 1, 1, 1, 2, 1, 7, 2, 2, 3, 8, 3, 1, 1, 3, 6, 2, 2, 2, 9, 8, 9, 3, 4, 2, 3, 3, 8, 0, 3, 0, 8, 1, 3, 5, 3, 3, 6, 2, 7, 6, 6, 1, 4, 2, 8, 2, 8, 0, 6, 4, 4, 4, 4, 8, 6, 6, 4, 5, 2, 3, 8, 7, 4, 9, 3, 0, 3, 5, 8, 9, 0, 7, 2, 9, 6, 2, 9, 0, 4, 9, 1, 5, 6, 0, 4, 4, 0, 7, 7, 2, 3, 9, 0, 7, 1, 3, 8, 1, 0, 5, 1, 5, 8, 5, 9, 3, 0, 7, 9, 6, 0, 8, 6, 6, 7, 0, 1, 7, 2, 4, 2, 7, 1, 2, 1, 8, 8, 3, 9, 9, 8, 7, 9, 7, 9, 0, 8, 7, 9, 2, 2, 7, 4, 9, 2, 1, 9, 0, 1, 6, 9, 9, 7, 2, 0, 8, 8, 8, 0, 9, 3, 7, 7, 6, 6, 5, 7, 2, 7, 3, 3, 3, 0, 0, 1, 0, 5, 3, 3, 6, 7, 8, 8, 1, 2, 2, 0, 2, 3, 5, 4, 2, 1, 8, 0, 9, 7, 5, 1, 2, 5, 4, 5, 4, 0, 5, 9, 4, 7, 5, 2, 2, 4, 3, 5, 2, 5, 8, 4, 9, 0, 7, 7, 1, 1, 6, 7, 0, 5, 5, 6, 0, 1, 3, 6, 0, 4, 8, 3, 9, 5, 8, 6, 4, 4, 6, 7, 0, 6, 3, 2, 4, 4, 1, 5, 7, 2, 2, 1, 5, 5, 3, 9, 7, 5, 3, 6, 9, 7, 8, 1, 7, 9, 7, 7, 8, 4, 6, 1, 7, 4, 0, 6, 4, 9, 5, 5, 1, 4, 9, 2, 9, 0, 8, 6, 2, 5, 6, 9, 3, 2, 1, 9, 7, 8, 4, 6, 8, 6, 2, 2, 4, 8, 2, 8, 3, 9, 7, 2, 2, 4, 1, 3, 7, 5, 6, 5, 7, 0, 5, 6, 0, 5, 7, 4, 9, 0, 2, 6, 1, 4, 0, 7, 9, 7, 2, 9, 6, 8, 6, 5, 2, 4, 1, 4, 5, 3, 5, 1, 0, 0, 4, 7, 4, 8, 2, 1, 6, 6, 3, 7, 0, 4, 8, 4, 4, 0, 3, 1, 9, 9, 8, 9, 0, 0, 0, 8, 8, 9, 5, 2, 4, 3, 4, 5, 0, 6, 5, 8, 5, 4, 1, 2, 2, 7, 5, 8, 8, 6, 6, 6, 8, 8, 1, 1, 6, 4, 2, 7, 1, 7, 1, 4, 7, 9, 9, 2, 4, 4, 4, 2, 9, 2, 8, 2, 3, 0, 8, 6, 3, 4, 6, 5, 6, 7, 4, 8, 1, 3, 9, 1, 9, 1, 2, 3, 1, 6, 2, 8, 2, 4, 5, 8, 6, 1, 7, 8, 6, 6, 4, 5, 8, 3, 5, 9, 1, 2, 4, 5, 6, 6, 5, 2, 9, 4, 7, 6, 5, 4, 5, 6, 8, 2, 8, 4, 8, 9, 1, 2, 8, 8, 3, 1, 4, 2, 6, 0, 7, 6, 9, 0, 0, 4, 2, 2, 4, 2, 1, 9, 0, 2, 2, 6, 7, 1, 0, 5, 5, 6, 2, 6, 3, 2, 1, 1, 1, 1, 1, 0, 9, 3, 7, 0, 5, 4, 4, 2, 1, 7, 5, 0, 6, 9, 4, 1, 6, 5, 8, 9, 6, 0, 4, 0, 8, 0, 7, 1, 9, 8, 4, 0, 3, 8, 5, 0, 9, 6, 2, 4, 5, 5, 4, 4, 4, 3, 6, 2, 9, 8, 1, 2, 3, 0, 9, 8, 7, 8, 7, 9, 9, 2, 7, 2, 4, 4, 2, 8, 4, 9, 0, 9, 1, 8, 8, 8, 4, 5, 8, 0, 1, 5, 6, 1, 6, 6, 0, 9, 7, 9, 1, 9, 1, 3, 3, 8, 7, 5, 4, 9, 9, 2, 0, 0, 5, 2, 4, 0, 6, 3, 6, 8, 9, 9, 1, 2, 5, 6, 0, 7, 1, 7, 6, 0, 6, 0, 5, 8, 8, 6, 1, 1, 6, 4, 6, 7, 1, 0, 9, 4, 0, 5, 0, 7, 7, 5, 4, 1, 0, 0, 2, 2, 5, 6, 9, 8, 3, 1, 5, 5, 2, 0, 0, 0, 5, 5, 9, 3, 5, 7, 2, 9, 7, 2, 5, 7, 1, 6, 3, 6, 2, 6, 9, 5, 6, 1, 8, 8, 2, 6, 7, 0, 4, 2, 8, 2, 5, 2, 4, 8, 3, 6, 0, 0, 8, 2, 3, 2, 5, 7, 5, 3, 0, 4, 2, 0, 7, 5, 2, 9, 6, 3, 4, 5, 0]

Drop n lst = Drop' n lst
Drop' 0 lst = lst
Drop' n [] = []
Drop' n h:tl = Drop' (n - 1) tl

Slice start len lst = Take len (Drop start lst)

Range from to = Take (to - from + 1) (NatsFrom from)

Gtr a b = if a > b then a else b

LargestProd lst len = LargestProd' lst len 0
LargestProd' [] len max = max
LargestProd' lst len max = LargestProd' (Tl lst) len (Gtr (Prod (Take len lst)) max)

Euler 8 = LargestProd Euler8Data 13

IterWhile pred EmptyIt = EmptyIt
IterWhile pred (It h tl) = if pred h then It h (NextIterWhile pred tl) else EmptyIt
Iter (NextIterWhile pred tl) = IterWhile pred (Iter tl)

Euler 10 = Sum (IterWhile (\n -> n < 2000000) Primes)

Scan f base it = Scan' f base it
Scan' f acc EmptyIt = EmptyIt
Scan' f acc (It h tl) = let next = f h acc in It next (NextScan f next tl)
Iter (NextScan f acc tl) = Scan' f acc (Iter tl)

Triangles = Scan (\h acc -> h + acc) 0 (NatsFrom 1)

DivisorsCount n = Prod (Map (\[n, e] -> e + 1) (RunLength (Factorize n)))

RunLength lst = RunLength' lst []
RunLength' [] enc = enc
RunLength' h:tl [] = RunLength' tl [[h, 1]]
RunLength' h:tl ([n, e]:enc) = RunLength' tl (if h == n then ([n, e + 1]:enc) else ([h, 1]:[n, e]:enc))

Find pred it = Find' pred it None
Find' pred it (Some x) = Some x
Find' pred EmptyIt b = None
Find' pred [] b = None
Find' pred (It h tl) None = Find' pred (Iter tl) (if pred h then Some h else None)
Find' pred h:tl None = Find' pred tl (if pred h then Some h else None)

Euler 12 = Unwrap (Find (\n -> DivisorsCount n > 500) Triangles)

Collatz 0 = Error
Collatz 1 = [1]
Collatz n = n : (Collatz (if Even n then n / 2 else 3 * n + 1))

MaxBy gtr (It h tl) = MaxBy' gtr h (Iter tl)
MaxBy gtr h:tl = MaxBy' gtr h tl
MaxBy' gtr h tl = Fold (\h max -> if gtr h max then h else max) h tl

Id = \x -> x

RangeIt from to = IterWhile (\n -> n <= to) (NatsFrom from)

CollatzLen n = CollatzLen' n 1
CollatzLen' 1 len = len
CollatzLen' n len = CollatzLen' (if Even n then n / 2 else 3 * n + 1) (len + 1)

Euler 14 = Hd (MaxBy (\[a, l1] [b, l2] -> l1 > l2) (Map (\n -> [n, CollatzLen n]) (RangeIt 1 1000000)))

LatticePaths 0 h m = [1, m]
LatticePaths w 0 m = [1, m]
LatticePaths w h m = LatticePaths' w h m (FindMemo [w, h] m)
LatticePaths' w h m (Some v) = [v, m]
LatticePaths' w h m None = let [a, m2] = LatticePaths (w - 1) h m in let [b, m3] = LatticePaths w (h - 1) m2 in [a + b, [[w, h], a + b]:m3]

Euler 15 = Hd (LatticePaths 20 20 [])

Map f None = None
Map f (Some x) = Some (f x)

Fst [a, b] = a
Snd [a, b] = b

FindMemo key memo = Map Snd (Find (\[k, v] -> k == key) memo)

IsSome (Some x) = True
IsSome x = False

Main = Euler 15